\documentclass{article}
% \usepackage{C:/Users/guitr/Documents/git_repositories/tpack/tpack}
% \usepackage{C:/Users/Admin-PC/Documents/git_repository/tpack/tpack}
\usepackage{/home/tr0fin0/Documents/git_repositories/tpack/tpack}
% \usepackage{/home/Documents/git_repositories/tpack/tpack}
\usetikzlibrary{decorations.pathreplacing,calligraphy}

\title{OS202 - Programming Parallel Computers}
\project{Travail Dirigée}
\author{Guilherme Nunes Trofino}
\authorRA{2022-2024}


\makeatletter
\begin{document}\selectlanguage{french}
\maketitle
\setlength{\parindent}{0pt}

\newcommand{\tableN}[3]{
    \begin{table}[H]
        \centering\begin{tabular}{lrl}
            n & secondes & MFloops\\
            \hline\hline
            #2
            \hline
            #3
            \hline
        \end{tabular}
        \caption{ordre \texttt{#1}}
    \end{table}
}



\newpage\tableofcontents

\section{Introduction}
% \subfile{C:/Users/guitr/Documents/git_repositories/classes_ensta/intro.tex}
% \subfile{C:/Users/Admin-PC/Documents/git_repository/classes_ensta/intro.tex}
\subfile{/home/tr0fin0/Documents/git_repositories/classes_ensta/intro.tex}
% \subfile{/home/Documents/git_repositories/classes_ensta/intro.tex}


\subsection{Information Matier}
\paragraph{Référence}Dans cette matière le but sera de comprendre \title{}. Ce travail est sur \href{https://github.com/JuvignyEnsta/Course2023/blob/main/TravauxDirig%C3%A9s/TD_numero_1/Sujet.pdf}{https://github.com/} avec l'objectif d'étudier et démontrer l'augmentation de performance quand on utilise la programmation parallèle.

\subsection{Caracteristiques Ordinateur}
\paragraph{CPU}On utilisé le commande \texttt{lscpu} pour avoir des informations sur le processeur de mon ordinateur en retournant le suivant:
\begin{scriptsize}
    % \mycode\lstinputlisting[language=bash]{example/main.cpp}
    \mycode
    \begin{lstlisting}[language=bash]
    Architecture:           x86_64
        CPU op-mode(s):         32-bit, 64-bit
        Address sizes:          39 bits physical, 48 bits virtual
        Byte Order:             Little Endian
        CPU(s):                 20
        On-line CPU(s) list:    0-19
        Vendor ID:              GenuineIntel
    Model name:            12th Gen Intel(R) Core(TM) i7-12700H
        CPU family:          6
        Model:               154
        Thread(s) per core:  2
        Core(s) per socket:  14
        Socket(s):           1
        Stepping:            3
        CPU max MHz:         4700.0000
        CPU min MHz:         400.0000
    \end{lstlisting}
\end{scriptsize}
On peut voir qui mon ordinateur a, théoriquement, 20 CPU's disponibles avec les mémoires suivants:
\begin{scriptsize}
    \mycode
    \begin{lstlisting}[language=bash]
    Caches (sum of all):     
        L1d:    544  KiB    (14 instances)
        L1i:    704  KiB    (14 instances)
        L2:     11.5 MiB    ( 8 instances)
        L3:     24   MiB    ( 1 instance)
    \end{lstlisting}
\end{scriptsize}
Ces données seront utilisés pour l'analyse des performances. 

% chercher hyperthreading
% essayer avec la librairie #pragemomp parallel for
% #pragma omp parallel for ... parallelise les for au dessous de la ligne de pragma
% BLAS libraire pour faire mieux les operations de multiplication de matrice en considerant les caracteristiques de l'ordinateur


\section{Produit Matrice-Matrice}
\subsection*{Question 1}
\begin{resolution}
    Les tailles suivants on était essayés:
    \tableN{ijk}{
        1023 & 1.17911 & 1815.94\\
        1024 & 2.89563 &  741.63\\
        1025 & 1.22712 & 1755.14\\
    }{
        2047 &  9.9369 & 1726.37\\
        2048 & 33.1686 & 517.956\\
        2049 & 10.2921 & 1671.68\\
    }
    On note qu'il y a une grand différence entre l'exécution avec une matrix de taille égale à une puissances de 2.\\

    Ce comportement peut être justifié avec la façon que la mémoire est gérer pour la CPU et pour la construction de la mémoire.\\

    Quand on utilise une variable à la position \texttt{i} c'est commun d'utiliser la variable à la position \texttt{i+1}. Le CPU considère ce principe et enregistre des variables en sequence.\\

    La mémoire est construit à partir des structures binaires donc elle aura une taille multiple de 2. Son addressage sera fait à partir du module de la taille de la mémoire.\\

    Quand il y a une matrice d'une taille multiple de 2, le module se rendre toujours au même endroit et donc chaque fois qui le CPU veut enregistre une variable il faut recopier tous les données en prenant plus de temps.
\end{resolution}

\newpage\subsection*{Question 2}
\begin{resolution}
    A
    \begin{center}
        \begin{minipage}[b]{0.3\textwidth}
            \tableN{ijk}{
                1023 & 1.17911 & 1815.94\\
                1024 & 2.89563 &  741.63\\
                1025 & 1.22712 & 1755.14\\
            }{
                2047 &  9.9369 & 1726.37\\
                2048 & 33.1686 & 517.956\\
                2049 & 10.2921 & 1671.68\\
            }
        \end{minipage}
        \begin{minipage}[b]{0.3\textwidth}
            \tableN{jik}{
                1023 & 1.26207 & 1696.58\\
                1024 & 3.01302 & 712.735\\
                1025 & 1.37956 & 1561.21\\
            }{
                2047 & 23.6272 & 726.057\\
                2048 & 70.8302 & 242.55\\
                2049 & 24.7906 & 694.016\\
            }
        \end{minipage}
        \begin{minipage}[b]{0.3\textwidth}
            \tableN{jki}{
                1023 & 0.394346 & 5429.74\\
                1024 & 0.407676 & 5267.63\\
                1025 & 0.416262 & 5174.1\\
            }{
                2047 & 4.91225 & 3492.23\\
                2048 & 5.02442 & 3419.27\\
                2049 & 5.12015 & 3360.27\\
            }
        \end{minipage}
    \end{center}

    \begin{center}
        \begin{minipage}[b]{0.3\textwidth}
            \tableN{ikj}{
                1023 & 2.38203 & 898.897\\
                1024 & 7.31333 & 293.64\\
                1025 & 2.13751 & 1007.61\\
            }{
                2047 & 76.2133 & 225.088\\
                2048 & 109.086 & 157.489\\
                2049 & 73.7907 & 233.16\\
            }
        \end{minipage}
        \begin{minipage}[b]{0.3\textwidth}
            \tableN{kij}{
                1023 & 2.27681 & 940.437\\
                1024 & 7.27702 & 295.105\\
                1025 & 2.52188 & 854.038\\
            }{
                2047 & 62.4818 & 274.555\\
                2048 & 132.456 & 129.702\\
                2049 & 73.0916 & 235.39\\
            }
        \end{minipage}
        \begin{minipage}[b]{0.3\textwidth}
            \tableN{kji}{
                1023 & 0.571053 & 3749.56\\
                1024 & 0.462365 & 4644.56\\
                1025 & 0.454393 & 4739.91\\
            }{
                2047 & 5.77844 & 2968.75\\
                2048 & 5.63255 & 3050.11\\
                2049 & 5.69804 & 3019.47\\
            }
        \end{minipage}
    \end{center}
    Comment précise pour la question précédent les données de la mémoire sont enregistres en groupe l'ordre entre lignes et colognes va influencer le résultat.\\

    Sur ma machine l'ordre \texttt{jki} était la plus efficace, les operations on pris moins de temps et la différence entre une matrice de taille multiple de 2 et une autre matrice n'était pas très significative.\\

    On considère le code suivant:
    \begin{scriptsize}
        \mycode\lstinputlisting[language=C++, linerange={11-17}]{ProdMatMat.cpp}
    \end{scriptsize}
    On peut voir:
    \begin{enumerate}[noitemsep]
        \item \texttt{i} représente les lignes;
        \item \texttt{j} représente les colognes;
    \end{enumerate}
    Comment l'algorithme est plus rapide quand l'interation "plus frequente" est sur \texttt{i} ça veut dire que les données sont estoquées pour lignes.
    % TODO confirm interpretation

    % \tableN{}{
    %     1023 &  & \\
    %     1024 &  & \\
    %     1025 &  & \\
    % }{
    %     2047 &  & \\
    %     2048 &  & \\
    %     2049 &  & \\
    % }
\end{resolution}

\newpage\subsection*{Question 3}
\begin{resolution}
    \href{https://stackoverflow.com/questions/22634121/openmp-c-matrix-multiplication-run-slower-in-parallel}
    
\end{resolution}

\newpage\subsection*{Question 4}
\begin{resolution}
    
\end{resolution}

\newpage\subsection*{Question 5}
\begin{resolution}
    
\end{resolution}

\newpage\subsection*{Question 6}
\begin{resolution}
    
\end{resolution}

\newpage\subsection*{Question 7}
\begin{resolution}
    
\end{resolution}

\newpage\subsection*{Question 8}
\begin{resolution}
    
\end{resolution}


\section{Parallélisation MPI, Circulation}

partie 2
tous les questions sont dans les examples et propablement sur youtube, pas trop difficile a faire


\subsection*{Question 1}
\begin{resolution}
    
\end{resolution}

\newpage\subsection*{Question 2}
\begin{resolution}
    
\end{resolution}

\newpage\subsection*{Question 3}
\begin{resolution}
    
\end{resolution}

\newpage\subsection*{Question 4}
\begin{resolution}
    
\end{resolution}

\newpage\subsection*{Question 5}
\begin{resolution}
    
\end{resolution}

\newpage\subsection*{Question 6}
\begin{resolution}
    
\end{resolution}

\newpage\subsection*{Question 7}
\begin{resolution}
    
\end{resolution}


\section{Parallélisation MPI, Calcul $\pi$}
\newpage\subsection*{Question 1}

\newpage\subsection*{Question 2}

\newpage\subsection*{Question 3}

\newpage\subsection*{Question 4}

\newpage\subsection*{Question 5}

\newpage\subsection*{Question 6}




\end{document}