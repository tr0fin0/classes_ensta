\documentclass{article}
% \usepackage{C:/Users/guitr/Documents/git_repositories/tpack/tpack}
% \usepackage{C:/Users/Admin-PC/Documents/git_repository/tpack/tpack}
\usepackage{/home/tr0fin0/Documents/git_repositories/tpack/tpack}
% \usepackage{/home/Documents/git_repositories/tpack/tpack}
\usetikzlibrary{decorations.pathreplacing,calligraphy}

\title{OS202 - Programming Parallel Computers}
\project{Travail Dirigée}
\author{Guilherme Nunes Trofino}
\authorRA{2022-2024}


\makeatletter
\begin{document}\selectlanguage{french}
\maketitle
\setlength{\parindent}{0pt}

\newcommand{\tableN}[3]{
    \begin{table}[H]
        \centering\begin{tabular}{lrl}
            n & secondes & MFloops\\
            \hline\hline
            #2
            \hline
            #3
            \hline
        \end{tabular}
        \caption{ordre \texttt{#1}}
    \end{table}
}



\newpage\tableofcontents

\section{Introduction}
% \subfile{C:/Users/guitr/Documents/git_repositories/classes_ensta/intro.tex}
% \subfile{C:/Users/Admin-PC/Documents/git_repository/classes_ensta/intro.tex}
\subfile{/home/tr0fin0/Documents/git_repositories/classes_ensta/intro.tex}
% \subfile{/home/Documents/git_repositories/classes_ensta/intro.tex}


\subsection{Information Matier}
\paragraph{Référence}Dans cette matière le but sera de comprendre \title{}. Ce travail est sur \href{https://github.com/JuvignyEnsta/Course2023/blob/main/TravauxDirig%C3%A9s/TD_numero_1/Sujet.pdf}{https://github.com/} avec l'objectif d'étudier et démontrer l'augmentation de performance quand on utilise la programmation parallèle.

\subsection{Caracteristiques Ordinateur}
\paragraph{CPU}On utilisé le commande \texttt{lscpu} pour avoir des informations sur le processeur de mon ordinateur en retournant le suivant:
\begin{scriptsize}
    % \mycode\lstinputlisting[language=bash]{example/main.cpp}
    \mycode
    \begin{lstlisting}[language=bash]
    Architecture:           x86_64
        CPU op-mode(s):         32-bit, 64-bit
        Address sizes:          39 bits physical, 48 bits virtual
        Byte Order:             Little Endian
        CPU(s):                 20
        On-line CPU(s) list:    0-19
        Vendor ID:              GenuineIntel
    Model name:            12th Gen Intel(R) Core(TM) i7-12700H
        CPU family:          6
        Model:               154
        Thread(s) per core:  2
        Core(s) per socket:  14
        Socket(s):           1
        Stepping:            3
        CPU max MHz:         4700.0000
        CPU min MHz:         400.0000
    \end{lstlisting}
\end{scriptsize}
On peut voir qui mon ordinateur a, théoriquement, 20 CPU's disponibles avec les mémoires suivants:
\begin{scriptsize}
    \mycode
    \begin{lstlisting}[language=bash]
    Caches (sum of all):     
        L1d:    544  KiB    (14 instances)
        L1i:    704  KiB    (14 instances)
        L2:     11.5 MiB    ( 8 instances)
        L3:     24   MiB    ( 1 instance)
    \end{lstlisting}
\end{scriptsize}
Ces données seront utilisés pour l'analyse des performances. 

% chercher hyperthreading
% essayer avec la librairie #pragemomp parallel for
% #pragma omp parallel for ... parallelise les for au dessous de la ligne de pragma
% BLAS libraire pour faire mieux les operations de multiplication de matrice en considerant les caracteristiques de l'ordinateur



lscpu commande pour avoir des informations sur l'ordinateur, plus précisement avec les CPUs.
chercher hyperthreading

TD 1
https://github.com/JuvignyEnsta/Course2023/blob/main/TravauxDirig%C3%A9s/TD_numero_1/Sujet.pdf

presenter le TD
presenter les caracteristiques de mon ordinateur pour justifier des conditions differents pour les essayes

question 1
    sans changement d'ordre ijk
        1023 1.17911 1815.94
        1024 2.89563  741.63
        1025 1.22712 1755.14

        2047  9.9369 1726.37
        2048 33.1686 517.956
        2049 10.2921 1671.68

    on note qu'il y a une grand différence entre l'exécution d'une programme avec une matrix de puissances de 2

    TODO justifier la différence de performance
        memoire cache associative
        quand il cherche une valeur, il guarde les valeurs proches
        matrixes stoques par colognes
        avec multiples de 2 il fau recopier les données par chaque fois qu'on a besoin d'information
        comme l'addressage est fait à partir du module des informations 

question 2
    changement d'ordre jik
        1023 1.26207 1696.58
        1024 3.01302 712.735
        1025 1.37956 1561.21

        2047 23.6272 726.057
        2048 70.8302 242.55
        2049 24.7906 694.016
    
essayer avec les parties de la matrice
regarder le fichier Transparent / examples pour avoir des programmes utilise
essayer avec la librairie #pragemomp parallel for
#pragma omp parallel for ... parallelise les for au dessous de la ligne de pragma


BLAS libraire pour faire mieux les operations de multiplication de matrice en considerant les caracteristiques de l'ordinateur



partie 2
tous les questions sont dans les examples et propablement sur youtube, pas trop difficile a faire


\subsection{Information Matier}
\paragraph{Référence}Dans cette matière le but sera de comprendre comment une Système d'Exploitation marche.

\end{document}