\documentclass{article}
\usepackage{C:/Users/guitr/Documents/git_repositories/tpack/tpack}
% \usepackage{C:/Users/Admin-PC/Documents/git_repository/tpack/tpack}
% \usepackage{/home/tr0fin0/git_repositories/tpack/tpack}
% \usepackage{/home/Documents/git_repositories/tpack/tpack}


\title{OI201 - Systèmes d'Exploitation}
\project{Résumé Théorique}
\author{Guilherme Nunes Trofino}
\authorRA{2022-2024}


\makeatletter
\begin{document}\selectlanguage{french}
\maketitle


\newpage\tableofcontents

\section{Introduction}
\subfile{C:/Users/guitr/Documents/git_repositories/classes_ensta/intro.tex}
% \subfile{C:/Users/Admin-PC/Documents/git_repository/classes_ensta/intro.tex}
% \subfile{/home/tr0fin0/git_repositories/classes_ensta/intro.tex}
% \subfile{/home/Documents/git_repositories/classes_ensta/intro.tex}


\subsection{Information Matier}
\paragraph{Référence}Dans cette matière le but sera de comprendre comment une Système d'Exploitation marche.

\subsection{Histoire}
\begin{definition}\label{def:batchProcessing}
    Ordinateurs que n'exécutent qu'un seul programme à la fois font du \textbf{Batch Processing}.\\
    
    Dans ce cas le programme n'a pas besoin de partage les resources de l'ordinateur. Il pourrait acceder:
    \begin{enumerate}[noitemsep]
        \item toute la mémoire;
        \item tout le processeur;
        \item tous les périphériques;
    \end{enumerate}

    \begin{phrase}
        un système d'exploitation n'est utile que lorsqu'il y a plusieurs programmes
    \end{phrase}
\end{definition}

\section{Architecture}
\subsection{Architecture Matérielle}
\begin{definition}
    Décrit l'agencement interne de composants électroniques ainsi que leurs interactions.

    \begin{phrase}
        représente tous les ressources physiques disponibles et accessibles de l'ordinateur
    \end{phrase}
\end{definition}
\subsubsection{Architecture Von Neumann}
\begin{definition}
    La même mémoire est utilisée pour stocker les instructions et les données des programmes.

    \begin{figure}[H]
        \centering
        \begin{tikzpicture}[]
        
            % modules
            \node[module] (CPU) {CPU};
            \node[module, right=of CPU] (BUS) {BUS};
            \node[module, below=of BUS] (MEM) {Mémoire};
            \node[module, right=of BUS] (PR0) {Périphériques};
            \node[module, above=5mm of PR0] (PR1) {Périphériques};
            \node[module, below=5mm of PR0] (PR2) {Périphériques};
            
            % connections
            \foreach \i in {0,1,2}
                \draw[<->] (BUS)--(PR\i);
            \draw[<->] (CPU)--(BUS);
            \draw[<->] (BUS)--(MEM);

        \end{tikzpicture}
    \end{figure}
    On considère comme des Périphériques: Clavier, Souris, USB, Réseau et Audio par exemple. 
\end{definition}

\subsubsection{Architecture Complet}
\begin{definition}
    On considère les éléments suivants comme les principales:
    \begin{figure}[H]
        \centering
        \begin{tikzpicture}[]
        
            % modules
            \node[module] (CPU) {CPU};
            \node[module, below=5mm of CPU] (MPU) {MPU};
            \node[module, right=of MPU] (BUS) {BUS};
            \node[module, below=of BUS] (MEM) {Mémoire};
            \node[module, right=of BUS] (PR0) {Périphériques};
            \node[module, above=5mm of PR0] (PR1) {Périphériques};
            \node[module, below=5mm of PR0] (PR2) {Périphériques};
            
            % connections
            \foreach \i in {0,1,2}
                \draw[<->] (BUS)--(PR\i);
            \draw[<->] (CPU)--(MPU);
            \draw[<->] (MPU)--(BUS);
            \draw[<->] (BUS)--(MEM);

        \end{tikzpicture}
    \end{figure}
\end{definition}



\section{Software}


\subsection{Taille d'Information}
\subsubsection{bit}
\begin{definition}
    Valeur binaire, soit 0 ou soit 1. La plus petite unité d'inforamtion.
\end{definition}

\subsubsection{octet}
\begin{definition}
    Généralement, un ensemble de 8 bits binaires. La plus petite unité de mémoire adressable.
    
    \begin{remark}
        Nomme \textbf{byte} en anglais.
    \end{remark}
\end{definition}

\subsubsection{mot}
\begin{definition}
    Ensemble de plusieurs \texttt{octets}. La unité de mémoire manipulée naturellement par un processeur: 8, 16, 32, 64 ou 128 bits.

    \begin{remark}
        Nomme \textbf{word} en anglais.
    \end{remark}
\end{definition}

\subsubsection{Padding}
\begin{definition}
    Consiste à garantir que la taille des données soit compatible avec les algorithmes utilisés.
\end{definition}

\subsubsection{Endianness}
\begin{definition}
    Convention pour lire les octets dans un mot:
    \begin{enumerate}[noitemsep]
        \item \textbf{big endian}: On commence par l'octet plus grand, gauche à droite;
        \item \textbf{little endian}: On commence par l'octet plus petit, droite à gauche;
    \end{enumerate}
    
    \begin{example}
        On considère le code suivante:
        \begin{scriptsize}\myRISCV
            \begin{lstlisting}
    variable = {0x11, 0x22, 0x33, 0x44};
    
    .word 0x11223344    # code little endian, plus commun
    
    .word 0x44332211    # code big endian
            \end{lstlisting}
        \end{scriptsize}
    \end{example}

    On peut convertir les variables d'une codage à une autre avec l'\href{https://codereview.stackexchange.com/questions/151049/endianness-conversion-in-c}{algorithme} suivant:
    \begin{scriptsize}\mycode
        \begin{lstlisting}[language=C, linerange={1-7}]
inline uint32_t Reverse32(uint32_t value) 
{
    return (((value & 0x000000FF) << 24) |
            ((value & 0x0000FF00) <<  8) |
            ((value & 0x00FF0000) >>  8) |
            ((value & 0xFF000000) >> 24));
}

inline uint32_t LittleEndian32(uint32_t value)
{
    #if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
        return value;
    #elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
        return Reverse32(value);
    #else
    #    error unsupported endianness
    #endif
}

inline uint32_t BigEndian32(uint32_t value)
{
    #if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
        return Reverse32(value);
    #elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
        return value;
    #else
    #    error unsupported endianness
    #endif
}
        \end{lstlisting}
    \end{scriptsize}
\end{definition}


\subsection{Noyau}
    Partie fondamentale du Système d'Exploitation, responsable privilégié pour gérer les ressources de l'ordinateur:
    \begin{enumerate}[noitemsep]
        \item \texttt{allocation}: comment répartir la mémoire
        \item \texttt{ordonnancement}: définir quel processus s'exécute à un instant;
    \end{enumerate}
    
    \begin{remark}
        Nomme \textbf{kernel} en anglais.
    \end{remark}
\end{definition}

\subsubsection{Service}
\begin{definition}
    Programme qui organise le partage de ressources de l'ordinateur.
\end{definition}

\subsubsection{Pilote Périphérique}
\begin{definition}
    Service responsable pour organiser le partage des périphériques de l'ordinateur en communicant avec le \textbf{noyau}.    
    
    \begin{remark}
        Nomme \textbf{driver} en anglais.
    \end{remark}
\end{definition}


\subsection{Ordonnanceur}
\begin{definition}
    Composant du noyau du système d'exploitation choisissant l'ordre d'exécution des processus sur les processeurs d'un ordinateur.
    
    \begin{remark}
        En anglais, l'Ordonnanceur est appelé \textbf{scheduler}.
    \end{remark}
    L'Ordonnanceur implémente une politique d'ordonnancement.
\end{definition}

\subsubsection{Politique d'Ordonnancement}
\begin{definition}
    Contraintes permettant de décider à tout instant quel travail exécuter par les travaux prêts.
\end{definition}
\subsubsection{Algorithme d'Ordonnancement}
\begin{definition}
    Représente la Politique d'Ordonnancements désiré pour le noyau comme par exemple:
    \begin{enumerate}[noitemsep, rightmargin = \leftmargin]
        \item \texttt{FIFO}: First in First Out, Premier Entré Premier Sorti, PEPS;
        \begin{example}
            File d'Attente, en anglais \textbf{queue}.
        \end{example}
        \item \texttt{LIFO}: Last in First Out, Dernier Entré Premier Sorti, DEPS;
        \begin{example}
            Pile, en anglais \textbf{stack};
        \end{example}
        \item \texttt{SJF}: Shortest Job First;
        \item \texttt{EDF}: Earliest Deadline First;
    \end{enumerate}
\end{definition}


\subsection{Système de Fenêtres}
\begin{definition}
    Seulement la fenêtre sélectionnée doit recevoir les entrées clavier et souris.
\end{definition}

\subsection{Système de Fichiers}
\begin{definition}
    Responsable pour organiser le partage de la Mémoire de Masse entre les différents fichiers.

    \begin{remark}
        Une mémoire de grande capacité, non volatile et qui peut être lue et écrite, entre autres, par un ordinateur est considère comme \textbf{Mémoire de Masse}.
    \end{remark}
\end{definition}
\subsubsection{Fichier}
\begin{definition}
    Représente un ensemble de secteurs, adressés en continu. 
\end{definition}

\subsubsection{Répertoires}
\begin{definition}
    Organisent les fichiers en une arborescence.
\end{definition}


\subsection{Système d'Exploitation}
\begin{definition}
    Au minimum un Système d'Exploitation est un ensemble composé de:
    \begin{enumerate}[noitemsep]
        \item \textbf{noyau};
        \item \textbf{services};
        \item \textbf{librairies};
    \end{enumerate}
\end{definition}



\section{Hardware}
\subsection{MPU}
\begin{definition}
    Positionné entre le CPU et le BUS, fait la gestion des registres spéciaux en guardant:
    \begin{enumerate}[noitemsep]
        \item Adresse de début;
        \item Adresse de fin;
        \item Permission;
    \end{enumerate}
    Tout accès mémoire en dehors de ces plages provoque une interruption.

    \begin{remark}
        Il faut modifier le paramétrage de la MPU quand on change de thread, seulement le noyau peut y acceder car le changement des registres de protection d'une MPU est privilégié.
    \end{remark}
\end{definition}



\section{Multi-Tâche}

\subsection{Thread}
\begin{definition}
    Séquence d'exécution indépendante qui peut avoir des statuts suivants:
    \begin{figure}[H]
        \centering
        \begin{tikzpicture}[]
        
        \node[state, initial] (S0) {prt};
        \node[state, above right= of S0] (S1) {att};
        \node[state, below right= of S1] (S2) {exe};

        \draw[->] (S0) edge[bend left, below]  node{élection}    (S2);
        \draw[->] (S2) edge[bend left, below]  node{préparation} (S0);
        \draw[->] (S1) edge[bend right, left]  node{déblocage}   (S0);
        \draw[->] (S2) edge[bend right, right] node{blocage}     (S1);

        \end{tikzpicture}
    \end{figure}
    Où: prt est \textbf{prêt}, att est \textbf{en attente} et exe est \textbf{en exécution}.
    
    \begin{remark}
        L'Unité d'Ordonnancement est responsable pour ordonner les Threads.
    \end{remark}
\end{definition}

\subsubsection{Processus}
\begin{definition}
    L'Ensemble Threads et ses permissions, donc avec son espace d'adressage séparé.

    \begin{remark}
        En général une instance de l'exécution d'un programme est considère comme Processus.
    \end{remark}
\end{definition}

\subsubsection{Atomicité}
\begin{definition}
    \texttt{f} est \textbf{atomique} par rapport à \texttt{g} si \texttt{f} apparaît s'exécuter d'un seul coup sans être interrompue par l'exécution de \texttt{g}.\\

    Deux fonctions \texttt{f} et \texttt{g} sont atomiques si l'exécution entrelacée de \texttt{f} et \texttt{g} est équivalente à une exécution séquentielle de \texttt{f} puis \texttt{g} ou de \texttt{g} puis \texttt{f}.
\end{definition}

\subsection{Tâche}
\begin{definition}
    Terme ambigu, souvent synonyme de Processus mais parfois de Thread. Il faut faire attention à son utilisation.
\end{definition}


\subsection{Synchronisation}
\begin{definition}
    Mécanismes permettant de coordonner l'exécution de plusieurs threads en bloquant leur exécution à des points de programmes précis pour régler les problèmes de concurrence sur l'accès à une ressource, logicielle ou matérielle, partagée.

    \begin{remark}
        Bloquer c'est à dire changer le statut de tâches à bloqué.
    \end{remark}
    \begin{remark}
        Débloquer c'est à dire changer le statut des taches à prêt.
    \end{remark}

    Pendant le changement entre threads la CPU restera inactif pour un des threads et donc perdra du temps d'exécution. Il faut copier les adresses de mémoire nécessaires que prend un peu de temps.
\end{definition}

\subsubsection{\texttt{mutex}}
\begin{definition}
    Utilisation de code qui permet de gérer des conflit pour ressources. 
\end{definition}

\subsubsection{Concurrence}
\begin{definition}
    Quand les tâches accèdent simultanément à une même ressource.
\end{definition}

\subsubsection{Parallélisme}
\begin{definition}
    Quand il y a utilisation de plusieurs resources.
\end{definition}


\section{Travail Dirigé}
\subsection{Séance 07/11/2022}
\paragraph{Définition}Dans ce TD on avait besoin de comprendre la structure et adresse de mémoire. Ainsi on considère le code suivant:
\begin{scriptsize}\mycode
    \begin{lstlisting}[language=C]
    struct p {
        uint32_t x; // 32 bits -> 4 octets
        uint16_t u; // 16 bits -> 2 octets
        uint32_t y; // 32 bits -> 4 octets
        uint32_t z; // 32 bits -> 4 octets
    } __attribute__((packed));;

    struct p *prt;
    \end{lstlisting}
\end{scriptsize}
Le \texttt{packed} assure que les champs des structures sont les uns à la suite des autres, donc il n'aura pas de \textbf{padding} pendant l'execution du code. Si \texttt{prt} point à l'adresse 0x1000 alors:
\begin{enumerate}[noitemsep]
    \item \texttt{\&(ptr->x)} pointe à l'adresse 0x1000
    \item \texttt{\&(ptr->u)} pointe à l'adresse 0x1004
    \item \texttt{\&(ptr->y)} pointe à l'adresse 0x1006
    \item \texttt{\&(ptr->z)} pointe à l'adresse 0x100A
\end{enumerate}
On rapelle que 0x represente des numéros hexadecimales.

\newpage\subsection{Séance 14/11/2022}
\paragraph{Définition}16 kilo octets = 16 kilo bytes = 16 000 bytes
dans le td il faut faire la plut part hardcoded
char *heap c'est un tableau de pointeurs et char heap c'est un tableau de char
memalloc doit reçu

\newpage\subsection{Séance 21/11/2022}
\paragraph{Définition}Dans ce TD on avait besoin de comprendre des \texttt{threads} coopératifs. Il faudra link les fichiers C et assembleur avec les options de compilateur \texttt{-static} comme montre:
\begin{scriptsize}\mycode
    \begin{lstlisting}[language=Bash]
        gcc -static file.s main.c -o main.exe
        ./main.exe
    \end{lstlisting}
\end{scriptsize}
On note que c'est nécessaire declarer des fonctions en Assemble avec les codes suivants:
\begin{scriptsize}\mycode
    \lstinputlisting[language=C, linerange={1-5}]{TD/2022_11_21/main.c}
\end{scriptsize}
\begin{scriptsize}\myRISCV
    \lstinputlisting[linerange={1-5}]{TD/2022_11_21/utils.s}
\end{scriptsize}

\newpage\subsection{Séance 28/11/2022}
\paragraph{Définition}Dans ce TD on avait besoin de comprendre des \texttt{interruptions} et le \texttt{ordonnancement} des instructions.
\begin{scriptsize}\mycode
    \lstinputlisting[language=C, linerange={1-5}]{TD/2022_11_28/main.c}
\end{scriptsize}
% gcc -static utils.s -g main.c -o main.exe
% gdb ./main.exe
% break enter_coroutine
% run
% n
% Thread 1 received signal SIGSEGV, Segmentation fault.

\newpage\subsection{Séance 05/12/2022}
\paragraph{Définition}
\begin{scriptsize}\mycode
    \lstinputlisting[language=C, linerange={1-5}]{TD/2022_12_05/main.c}
\end{scriptsize}
\end{document}